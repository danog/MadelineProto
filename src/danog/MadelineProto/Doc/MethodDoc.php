<?php
/**
 * This file is automatic generated by build_docs.php file
 * and is used only for autocomplete in multiple IDE
 * don't modify manually.
 */

namespace danog\MadelineProto\Doc;

class MethodDoc extends NamespaceDoc
{
    protected function cloneProxy(): self
    {
        return new self;
    }
    protected function getAPINamespaces(): array
    {
        return [
  0 => 'auth',
  1 => 'account',
  2 => 'users',
  3 => 'contacts',
  4 => 'messages',
  5 => 'updates',
  6 => 'photos',
  7 => 'upload',
  8 => 'help',
  9 => 'channels',
  10 => 'bots',
  11 => 'payments',
  12 => 'stickers',
  13 => 'phone',
  14 => 'langpack',
  15 => 'folders',
  16 => 'stats',
];
    }
    /**
         * Convert MTProto parameters to bot API parameters.
         *
         * @param array $data Data
         *
         * @return \Amp\Promise<array>
         */
    public function MTProtoToBotAPI(array $data, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$data, $extra]);
    }
    /**
     * MTProto to TD params.
     *
     * @param mixed $params Params
     *
     * @return \Amp\Promise
     */
    public function MTProtoToTd(&$params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * MTProto to TDCLI params.
     *
     * @param mixed $params Params
     *
     * @return \Amp\Promise
     */
    public function MTProtoToTdcli($params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Accept call.
     *
     * @param array $call Call
     *
     * @return \Amp\Promise
     */
    public function acceptCall(array $call, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$call, $extra]);
    }
    /**
     * Accept secret chat.
     *
     * @param array $params Secret chat ID
     *
     * @return \Amp\Promise
     */
    public function acceptSecretChat($params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Accept terms of service update.
     *
     * @return \Amp\Promise
     */
    public function acceptTos(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Add user info.
     *
     * @param array $user User info
     *
     * @return \Amp\Promise
     * @throws \danog\MadelineProto\Exception
     */
    public function addUser(array $user, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$user, $extra]);
    }
    /**
     * Call promise $b after promise $a.
     *
     * @param \Generator|Promise $a Promise A
     * @param \Generator|Promise $b Promise B
     *
     * @psalm-suppress InvalidScope
     *
     * @return \Amp\Promise
     */
    public function after($a, $b)
    {
        return \danog\MadelineProto\Tools::after($a, $b);
    }
    /**
     * Returns a promise that succeeds when all promises succeed, and fails if any promise fails.
     * Returned promise succeeds with an array of values used to succeed each contained promise, with keys corresponding to the array of promises.
     *
     * @param array<\Generator|Promise> $promises Promises
     *
     * @return \Amp\Promise
     */
    public function all(array $promises)
    {
        return \danog\MadelineProto\Tools::all($promises);
    }
    /**
     * Returns a promise that is resolved when all promises are resolved. The returned promise will not fail.
     *
     * @param array<Promise|\Generator> $promises Promises
     *
     * @return \Amp\Promise
     */
    public function any(array $promises)
    {
        return \danog\MadelineProto\Tools::any($promises);
    }
    /**
     * Create array.
     *
     * @param mixed ...$params Params
     *
     * @return array
     */
    public function arr(...$params): array
    {
        return \danog\MadelineProto\Tools::arr(...$params);
    }
    /**
     * base64URL decode.
     *
     * @param string $data Data to decode
     *
     * @return string
     */
    public function base64urlDecode(string $data): string
    {
        return \danog\MadelineProto\Tools::base64urlDecode($data);
    }
    /**
     * Base64URL encode.
     *
     * @param string $data Data to encode
     *
     * @return string
     */
    public function base64urlEncode(string $data): string
    {
        return \danog\MadelineProto\Tools::base64urlEncode($data);
    }
    /**
     * Convert bot API parameters to MTProto parameters.
     *
     * @param array $arguments Arguments
     *
     * @return \Amp\Promise<array>
     */
    public function botAPIToMTProto(array $arguments, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$arguments, $extra]);
    }
    /**
     * Login as bot.
     *
     * @param string $token Bot token
     *
     * @return \Amp\Promise
     */
    public function botLogin(string $token, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$token, $extra]);
    }
    /**
     * Convert generator, promise or any other value to a promise.
     *
     * @param \Generator|Promise|mixed $promise
     *
     * @template TReturn
     * @psalm-param \Generator<mixed, mixed, mixed, TReturn>|Promise<TReturn>|TReturn $promise
     *
     * @return \Amp\Promise
     * @psalm-return Promise<TReturn>
     */
    public function call($promise)
    {
        return \danog\MadelineProto\Tools::call($promise);
    }
    /**
     * Call promise in background.
     *
     * @param \Generator|Promise  $promise Promise to resolve
     * @param ?\Generator|Promise $actual  Promise to resolve instead of $promise
     * @param string              $file    File
     *
     * @psalm-suppress InvalidScope
     *
     * @return \Amp\Promise|mixed
     */
    public function callFork($promise, $actual = null, $file = '')
    {
        return \danog\MadelineProto\Tools::callFork($promise, $actual, $file);
    }
    /**
     * Call promise in background, deferring execution.
     *
     * @param \Generator|Promise $promise Promise to resolve
     *
     * @return void
     */
    public function callForkDefer($promise): void
    {
        \danog\MadelineProto\Tools::callForkDefer($promise);
    }
    /**
     * Get call status.
     *
     * @param int $id Call ID
     *
     * @psalm-return int|\Amp\Promise<int>
     * @return mixed
     */
    public function callStatus($id)
    {
        return $this->__call(__FUNCTION__, [$id]);
    }
    /**
     * Check for terms of service update.
     *
     * @return \Amp\Promise
     */
    public function checkTos(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Cleanup memory and session file.
     *
     * @return \Amp\Promise
     */
    public function cleanup(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Close connection with client, connected via web.
     *
     * @param string $message Message
     *
     * @return void
     */
    public function closeConnection($message)
    {
        return \danog\MadelineProto\Tools::closeConnection($message);
    }
    /**
     * Complete 2FA login.
     *
     * @param string $password Password
     *
     * @return \Amp\Promise
     */
    public function complete2faLogin(string $password, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$password, $extra]);
    }
    /**
     * Complete call handshake.
     *
     * @param array $params Params
     *
     * @return \Amp\Promise
     */
    public function completeCall(array $params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Complet user login using login code.
     *
     * @param string $code Login code
     *
     * @return \Amp\Promise
     */
    public function completePhoneLogin($code, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$code, $extra]);
    }
    /**
     * Complete signup to Telegram.
     *
     * @param string $first_name First name
     * @param string $last_name  Last name
     *
     * @return \Amp\Promise
     */
    public function completeSignup(string $first_name, string $last_name = '', array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$first_name, $last_name, $extra]);
    }
    /**
     * Confirm call.
     *
     * @param array $params Params
     *
     * @return \Amp\Promise
     */
    public function confirmCall(array $params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Connects to all datacenters and if necessary creates authorization keys, binds them and writes client info.
     *
     * @param boolean $reconnectAll Whether to reconnect to all DCs
     *
     * @return \Amp\Promise
     */
    public function connectToAllDcs(bool $reconnectAll = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$reconnectAll, $extra]);
    }
    /**
     * Decline terms of service update.
     *
     * THIS WILL DELETE YOUR ACCOUNT!
     *
     * @return \Amp\Promise
     */
    public function declineTos(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Discard call.
     *
     * @param array   $call       Call
     * @param array $reason
     * @param array   $rating     Rating
     * @param boolean $need_debug Need debug?
     *
     * @return \Amp\Promise
     */
    public function discardCall(array $call, array $reason, array $rating = [
    ], bool $need_debug = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$call, $reason, $rating, $need_debug, $extra]);
    }
    /**
     * Discard secret chat.
     *
     * @param int $chat Secret chat ID
     *
     * @return \Amp\Promise
     */
    public function discardSecretChat(int $chat, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$chat, $extra]);
    }
    /**
     * Download file to browser.
     *
     * Supports HEAD requests and content-ranges for parallel and resumed downloads.
     *
     * @param array|string $messageMedia File to download
     * @param callable     $cb           Status callback (can also use FileCallback)
     *
     * @return \Amp\Promise
     */
    public function downloadToBrowser($messageMedia, ?callable $cb = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $cb, $extra]);
    }
    /**
     * Download file to callable.
     * The callable must accept two parameters: string $payload, int $offset
     * The callable will be called (possibly out of order, depending on the value of $seekable).
     * The callable should return the number of written bytes.
     *
     * @param mixed                          $messageMedia File to download
     * @param callable|FileCallbackInterface $callable      Chunk callback
     * @param callable                       $cb            Status callback (DEPRECATED, use FileCallbackInterface)
     * @param bool                           $seekable      Whether the callable can be called out of order
     * @param int                            $offset        Offset where to start downloading
     * @param int                            $end           Offset where to stop downloading (inclusive)
     * @param int                            $part_size     Size of each chunk
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<true>
     */
    public function downloadToCallable($messageMedia, callable $callable, $cb = null, bool $seekable = true, int $offset = 0, int $end = -1, ?int $part_size = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $callable, $cb, $seekable, $offset, $end, $part_size, $extra]);
    }
    /**
     * Download file to directory.
     *
     * @param mixed                        $messageMedia File to download
     * @param string|FileCallbackInterface $dir           Directory where to download the file
     * @param callable                     $cb            Callback (DEPRECATED, use FileCallbackInterface)
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<false|string>
     */
    public function downloadToDir($messageMedia, $dir, $cb = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $dir, $cb, $extra]);
    }
    /**
     * Download file.
     *
     * @param mixed                        $messageMedia File to download
     * @param string|FileCallbackInterface $file          Downloaded file path
     * @param callable                     $cb            Callback (DEPRECATED, use FileCallbackInterface)
     *
     * @return \Amp\Promise Downloaded file path
     *
     * @psalm-return \Amp\Promise<false|string>
     */
    public function downloadToFile($messageMedia, $file, $cb = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $file, $cb, $extra]);
    }
    /**
     * Download file to amphp/http-server response.
     *
     * Supports HEAD requests and content-ranges for parallel and resumed downloads.
     *
     * @param array|string  $messageMedia File to download
     * @param ServerRequest $request      Request
     * @param callable      $cb           Status callback (can also use FileCallback)
     *
     * @return \Amp\Promise Returned response
     *
     * @psalm-return \Amp\Promise<\Amp\Http\Server\Response>
     */
    public function downloadToResponse($messageMedia, \Amp\Http\Server\Request $request, ?callable $cb = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $request, $cb, $extra]);
    }
    /**
     * Download file to stream.
     *
     * @param mixed                       $messageMedia File to download
     * @param mixed|FileCallbackInterface $stream        Stream where to download file
     * @param callable                    $cb            Callback (DEPRECATED, use FileCallbackInterface)
     * @param int                         $offset        Offset where to start downloading
     * @param int                         $end           Offset where to end download
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function downloadToStream($messageMedia, $stream, $cb = null, int $offset = 0, int $end = -1, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $stream, $cb, $offset, $end, $extra]);
    }
    /**
     * Asynchronously write to stdout/browser.
     *
     * @param string $string Message to echo
     *
     * @return \Amp\Promise
     */
    public function echo(string $string)
    {
        return \danog\MadelineProto\Tools::echo($string);
    }
    /**
     * Get final element of array.
     *
     * @param array $what Array
     *
     * @return mixed
     */
    public function end(array $what)
    {
        return \danog\MadelineProto\Tools::end($what);
    }
    /**
     * Export authorization.
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<array{0: int|string, 1: string}>
     */
    public function exportAuthorization(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Extract file info from bot API message.
     *
     * @param array $info Bot API message object
     *
     * @return ?array
     */
    public function extractBotAPIFile(array $info): ?array
    {
        return \danog\MadelineProto\MTProto::extractBotAPIFile($info);
    }
    /**
     * Get contents of remote file asynchronously.
     *
     * @param string $url URL
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<string>
     */
    public function fileGetContents(string $url, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$url, $extra]);
    }
    /**
     * Returns a promise that succeeds when the first promise succeeds, and fails only if all promises fail.
     *
     * @param array<Promise|\Generator> $promises Promises
     *
     * @return \Amp\Promise
     */
    public function first(array $promises)
    {
        return \danog\MadelineProto\Tools::first($promises);
    }
    /**
     * Asynchronously lock a file
     * Resolves with a callbable that MUST eventually be called in order to release the lock.
     *
     * @param string    $file      File to lock
     * @param integer   $operation Locking mode
     * @param float     $polling   Polling interval
     * @param ?Promise  $token     Cancellation token
     * @param ?callable $failureCb Failure callback, called only once if the first locking attempt fails.
     *
     * @return \Amp\Promise<$token is null ? callable : ?callable>
     */
    public function flock(string $file, int $operation, float $polling = 0.1, ?\Amp\Promise $token = null, $failureCb = null)
    {
        return \danog\MadelineProto\Tools::flock($file, $operation, $polling, $token, $failureCb);
    }
    /**
     * Convert bot API channel ID to MTProto channel ID.
     *
     * @param int $id Bot API channel ID
     *
     * @return int
     */
    public function fromSupergroup($id): int
    {
        return \danog\MadelineProto\MTProto::fromSupergroup($id);
    }
    /**
     * When were full info for this chat last cached.
     *
     * @param mixed $id Chat ID
     *
     * @return \Amp\Promise<integer>
     */
    public function fullChatLastUpdated($id, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $extra]);
    }
    /**
     * Get info about the logged-in user, not cached.
     *
     * @return \Amp\Promise<array|bool>
     */
    public function fullGetSelf(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Generate MTProto vector hash.
     *
     * @param array $ints IDs
     *
     * @return string Vector hash
     */
    public function genVectorHash(array $ints): string
    {
        return \danog\MadelineProto\Tools::genVectorHash($ints);
    }
    /**
     * Get full list of MTProto and API methods.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getAllMethods()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get authorization info.
     *
     * @psalm-return int|\Amp\Promise<int>
     * @return mixed
     */
    public function getAuthorization()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get cached server-side config.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getCachedConfig()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get call info.
     *
     * @param int $call Call ID
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getCall($call)
    {
        return $this->__call(__FUNCTION__, [$call]);
    }
    /**
     * Store RSA keys for CDN datacenters.
     *
     * @param string $datacenter DC ID
     *
     * @return \Amp\Promise
     */
    public function getCdnConfig(string $datacenter, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$datacenter, $extra]);
    }
    /**
     * Get cached (or eventually re-fetch) server-side config.
     *
     * @param array $config  Current config
     * @param array $options Options for method call
     *
     * @return \Amp\Promise
     */
    public function getConfig(array $config = [
    ], array $options = [
    ], array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$config, $options, $extra]);
    }
    /**
     * Called right before deserialization of object.
     *
     * Pass only the constructor name
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getConstructorBeforeCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Called right after deserialization of object, passing the final object.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getConstructorCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Called right before serialization of constructor.
     *
     * Passed the object, will return a modified version.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getConstructorSerializeCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get async DNS client.
     *
     * @psalm-return \Amp\Dns\Resolver|\Amp\Promise<\Amp\Dns\Resolver>
     * @return mixed
     */
    public function getDNSClient()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get all datacenter connections.
     *
     * @psalm-return array<DataCenterConnection>|\Amp\Promise<array<DataCenterConnection>>
     * @return mixed
     */
    public function getDataCenterConnections()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get main DC ID.
     *
     * @return int|string
     */
    public function getDataCenterId(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Get dialog peers.
     *
     * @param boolean $force Whether to refetch all dialogs ignoring cache
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<list<mixed>>
     */
    public function getDialogs(bool $force = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$force, $extra]);
    }
    /**
     * Get download info of file
     * Returns an array with the following structure:.
     *
     * `$info['ext']` - The file extension
     * `$info['name']` - The file name, without the extension
     * `$info['mime']` - The file mime type
     * `$info['size']` - The file size
     *
     * @param mixed $messageMedia File ID
     *
     * @return \Amp\Promise<array>
     */
    public function getDownloadInfo($messageMedia, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$messageMedia, $extra]);
    }
    /**
     * Get event handler.
     *
     * @psalm-return \danog\MadelineProto\EventHandler|\Amp\Promise<\danog\MadelineProto\EventHandler>
     * @return mixed
     */
    public function getEventHandler()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get extension from file location.
     *
     * @param mixed  $location File location
     * @param string $default  Default extension
     *
     * @return string
     */
    public function getExtensionFromLocation($location, string $default): string
    {
        return \danog\MadelineProto\TL\Conversion\Extension::getExtensionFromLocation($location, $default);
    }
    /**
     * Get extension from mime type.
     *
     * @param string $mime MIME type
     *
     * @return string
     */
    public function getExtensionFromMime(string $mime): string
    {
        return \danog\MadelineProto\TL\Conversion\Extension::getExtensionFromMime($mime);
    }
    /**
     * Get info about file.
     *
     * @param mixed $constructor File ID
     *
     * @return \Amp\Promise<array>
     */
    public function getFileInfo($constructor, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$constructor, $extra]);
    }
    /**
     * Get folder ID from object.
     *
     * @param mixed $id Object
     *
     * @return ?int
     */
    public function getFolderId($id): ?int
    {
        return \danog\MadelineProto\MTProto::getFolderId($id);
    }
    /**
     * Get full info of all dialogs.
     *
     * @param boolean $force Whether to refetch all dialogs ignoring cache
     *
     * @return \Amp\Promise
     */
    public function getFullDialogs(bool $force = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$force, $extra]);
    }
    /**
     * Get full info about peer, returns an FullInfo object.
     *
     * @param mixed $id Peer
     *
     * @see https://docs.madelineproto.xyz/FullInfo.html
     *
     * @return \Amp\Promise FullInfo object
     *
     * @psalm-return \Amp\Promise<array>
     */
    public function getFullInfo($id, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $extra]);
    }
    /**
     * Get async HTTP client.
     *
     * @psalm-return \Amp\Http\Client\HttpClient|\Amp\Promise<\Amp\Http\Client\HttpClient>
     * @return mixed
     */
    public function getHTTPClient()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get current password hint.
     *
     * @psalm-return string|\Amp\Promise<string>
     * @return mixed
     */
    public function getHint()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get bot API ID from peer object.
     *
     * @param mixed $id Peer
     *
     * @return int
     */
    public function getId($id, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $extra]);
    }
    /**
     * Get info about peer, returns an Info object.
     *
     * @param mixed                $id        Peer
     * @param MTProto::INFO_TYPE_* $type      Whether to generate an Input*, an InputPeer or the full set of constructors
     * @param boolean              $recursive Internal
     *
     * @see https://docs.madelineproto.xyz/Info.html
     *
     * @return \Amp\Promise Info object
     *
     * @template TConstructor
     * @psalm-param $id array{_: TConstructor}|mixed
     *
     * @return (((mixed|string)[]|mixed|string)[]|int|mixed|string)[]
     *
     * @psalm-return \Generator<int|mixed, \Amp\Promise|\Amp\Promise<string>|array, mixed, array{
     *      TConstructor: array
     *      InputPeer: array{_: string, user_id?: mixed, access_hash?: mixed, min?: mixed, chat_id?: mixed, channel_id?: mixed},
     *      Peer: array{_: string, user_id?: mixed, chat_id?: mixed, channel_id?: mixed},
     *      DialogPeer: array{_: string, peer: array{_: string, user_id?: mixed, chat_id?: mixed, channel_id?: mixed}},
     *      NotifyPeer: array{_: string, peer: array{_: string, user_id?: mixed, chat_id?: mixed, channel_id?: mixed}},
     *      InputDialogPeer: array{_: string, peer: array{_: string, user_id?: mixed, access_hash?: mixed, min?: mixed, chat_id?: mixed, channel_id?: mixed}},
     *      InputNotifyPeer: array{_: string, peer: array{_: string, user_id?: mixed, access_hash?: mixed, min?: mixed, chat_id?: mixed, channel_id?: mixed}},
     *      bot_api_id: int|string,
     *      user_id?: int,
     *      chat_id?: int,
     *      channel_id?: int,
     *      InputUser?: array{_: string, user_id?: int, access_hash?: mixed, min?: bool},
     *      InputChannel?: array{_: string, channel_id: int, access_hash: mixed, min: bool},
     *      type: string
     * }>|int|array{_: string, user_id?: mixed, access_hash?: mixed, min?: mixed, chat_id?: mixed, channel_id?: mixed}|array{_: string, user_id?: int, access_hash?: mixed, min?: bool}|array{_: string, channel_id: int, access_hash: mixed, min: bool}
     */
    public function getInfo($id, int $type = \danog\MadelineProto\MTProto::INFO_TYPE_ALL, $recursive = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $type, $recursive, $extra]);
    }
    /**
     * Get logger.
     */
    public function getLogger()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Called right before serialization of method starts.
     *
     * Pass the method name
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getMethodBeforeCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Called right before serialization of method starts.
     *
     * Pass the method name
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getMethodCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get TL namespaces.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getMethodNamespaces()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get namespaced methods (method => namespace).
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getMethodsNamespaced()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get mime type from buffer.
     *
     * @param string $buffer Buffer
     *
     * @return string
     */
    public function getMimeFromBuffer(string $buffer): string
    {
        return \danog\MadelineProto\TL\Conversion\Extension::getMimeFromBuffer($buffer);
    }
    /**
     * Get mime type from file extension.
     *
     * @param string $extension File extension
     * @param string $default   Default mime type
     *
     * @return string
     */
    public function getMimeFromExtension(string $extension, string $default): string
    {
        return \danog\MadelineProto\TL\Conversion\Extension::getMimeFromExtension($extension, $default);
    }
    /**
     * Get mime type of file.
     *
     * @param string $file File
     *
     * @return string
     */
    public function getMimeFromFile(string $file): string
    {
        return \danog\MadelineProto\TL\Conversion\Extension::getMimeFromFile($file);
    }
    /**
     * Get download info of the propic of a user
     * Returns an array with the following structure:.
     *
     * `$info['ext']` - The file extension
     * `$info['name']` - The file name, without the extension
     * `$info['mime']` - The file mime type
     * `$info['size']` - The file size
     *
     * @param mixed $messageMedia File ID
     *
     * @return \Amp\Promise<array>
     */
    public function getPropicInfo($data, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$data, $extra]);
    }
    /**
     * Get PSR logger.
     */
    public function getPsrLogger()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get full info about peer (including full list of channel members), returns a Chat object.
     *
     * @param mixed $id Peer
     *
     * @see https://docs.madelineproto.xyz/Chat.html
     *
     * @return \Amp\Promise Chat object
     */
    public function getPwrChat($id, bool $fullfetch = true, bool $send = true, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $fullfetch, $send, $extra]);
    }
    /**
     * Get secret chat.
     *
     * @param array|int $chat Secret chat ID
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getSecretChat($chat)
    {
        return $this->__call(__FUNCTION__, [$chat]);
    }
    /**
     * Get info about the logged-in user, cached.
     *
     * @return array|bool
     */
    public function getSelf(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Return current settings.
     *
     * @psalm-return \danog\MadelineProto\Settings|\Amp\Promise<\danog\MadelineProto\Settings>
     * @return mixed
     */
    public function getSettings()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Get sponsored messages for channel.
     * This method will return an array of [sponsored message objects](https://docs.madelineproto.xyz/API_docs/constructors/sponsoredMessage.html).
     *
     * See [the API documentation](https://core.telegram.org/api/sponsored-messages) for more info on how to handle sponsored messages.
     *
     * @param int|array $peer Channel ID, or Update, or Message, or Peer.
     * @return \Amp\Promise
     */
    public function getSponsoredMessages($peer, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$peer, $extra]);
    }
    /**
     * Get TL serializer.
     *
     * @psalm-return \danog\MadelineProto\TL\TL|\Amp\Promise<\danog\MadelineProto\TL\TL>
     * @return mixed
     */
    public function getTL()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Called if objects of the specified type cannot be serialized.
     *
     * Passed the unserializable object,
     * will try to convert it to an object of the proper type.
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function getTypeMismatchCallbacks()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Accesses a private variable from an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     *
     * @psalm-suppress InvalidScope
     *
     * @return mixed
     * @access public
     */
    public function getVar($obj, string $var)
    {
        return \danog\MadelineProto\Tools::getVar($obj, $var);
    }
    /**
     * Get a message to show to the user when starting the bot.
     *
     * @param string $message
     */
    public function getWebMessage(string $message)
    {
        return $this->__call(__FUNCTION__, [$message]);
    }
    /**
     * Get web template.
     *
     * @psalm-return string|\Amp\Promise<string>
     * @return mixed
     */
    public function getWebTemplate()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Checks whether all datacenters are authorized.
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function hasAllAuth()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Check if an event handler instance is present.
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function hasEventHandler()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Check if has report peers.
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function hasReportPeers()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Check whether secret chat exists.
     *
     * @param array|int $chat Secret chat ID
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function hasSecretChat($chat)
    {
        return $this->__call(__FUNCTION__, [$chat]);
    }
    /**
     * Checks private property exists in an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     *
     * @psalm-suppress InvalidScope
     *
     * @return bool
     * @access public
     */
    public function hasVar($obj, string $var): bool
    {
        return \danog\MadelineProto\Tools::hasVar($obj, $var);
    }
    /**
     * Import authorization.
     *
     * @param array<int, string> $authorization Authorization info
     * @param int $mainDcID Main DC ID
     *
     * @return \Amp\Promise
     */
    public function importAuthorization(array $authorization, int $mainDcID, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$authorization, $mainDcID, $extra]);
    }
    /**
     * Inflate stripped photosize to full JPG payload.
     *
     * @param string $stripped Stripped photosize
     *
     * @return string JPG payload
     */
    public function inflateStripped(string $stripped): string
    {
        return \danog\MadelineProto\Tools::inflateStripped($stripped);
    }
    /**
     * Initialize self-restart hack.
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function initSelfRestart()
    {
        $this->__call(__FUNCTION__, []);
    }
    /**
     * Whether this is altervista.
     *
     * @return boolean
     */
    public function isAltervista(): bool
    {
        return \danog\MadelineProto\Tools::isAltervista();
    }
    /**
     * Check if is array or similar (traversable && countable && arrayAccess).
     *
     * @param mixed $var Value to check
     *
     * @return boolean
     */
    public function isArrayOrAlike($var): bool
    {
        return \danog\MadelineProto\Tools::isArrayOrAlike($var);
    }
    /**
     * Whether we're an IPC client instance.
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function isIpc()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Whether we're an IPC server process (as opposed to an event handler).
     *
     * @psalm-return bool|\Amp\Promise<bool>
     * @return mixed
     */
    public function isIpcWorker()
    {
        return $this->__call(__FUNCTION__, []);
    }
    /**
     * Check whether provided bot API ID is a channel.
     *
     * @param int $id Bot API ID
     *
     * @return boolean
     */
    public function isSupergroup($id): bool
    {
        return \danog\MadelineProto\MTProto::isSupergroup($id);
    }
    /**
     * Logger.
     *
     * @param string $param Parameter
     * @param int    $level Logging level
     * @param string $file  File where the message originated
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function logger($param, int $level = \danog\MadelineProto\Logger::NOTICE, string $file = '')
    {
        $this->__call(__FUNCTION__, [$param, $level, $file]);
    }
    /**
     * Log out currently logged in user.
     *
     * @return \Amp\Promise
     */
    public function logout(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Start MadelineProto's update handling loop, or run the provided async callable.
     *
     * @param callable|null $callback Async callable to run
     *
     * @return \Amp\Promise
     */
    public function loop($callback = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$callback, $extra]);
    }
    /**
     * Start MadelineProto's update handling loop in background.
     *
     * @return \Amp\Promise
     */
    public function loopFork(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Escape string for markdown.
     *
     * @param string $hwat String to escape
     *
     * @return string
     */
    public function markdownEscape(string $hwat): string
    {
        return \danog\MadelineProto\StrTools::markdownEscape($hwat);
    }
    /**
     * Telegram UTF-8 multibyte split.
     *
     * @param string  $text   Text
     * @param integer $length Length
     *
     * @return array
     */
    public function mbStrSplit(string $text, int $length): array
    {
        return \danog\MadelineProto\MTProto::mbStrSplit($text, $length);
    }
    /**
     * Get Telegram UTF-8 length of string.
     *
     * @param string $text Text
     *
     * @return float|int
     */
    public function mbStrlen(string $text)
    {
        return $this->__call(__FUNCTION__, [$text]);
    }
    /**
     * Telegram UTF-8 multibyte substring.
     *
     * @param string  $text   Text to substring
     * @param integer $offset Offset
     * @param ?int    $length Length
     *
     * @return string
     */
    public function mbSubstr(string $text, int $offset, $length = null): string
    {
        return \danog\MadelineProto\MTProto::mbSubstr($text, $offset, $length);
    }
    /**
     * Call method and wait asynchronously for response.
     *
     * If the $aargs['noResponse'] is true, will not wait for a response.
     *
     * @param string            $method Method name
     * @param array|\Generator  $args   Arguments
     * @param array             $aargs  Additional arguments
     *
     * @psalm-param array|\Generator<mixed, mixed, mixed, array> $args
     *
     * @return \Amp\Promise
     */
    public function methodCall(string $method, $args = [
    ], array $aargs = [
      'msg_id' => null,
    ], array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$method, $args, $aargs, $extra]);
    }
    /**
     * Call method and make sure it is asynchronously sent.
     *
     * @param string            $method Method name
     * @param array|\Generator  $args   Arguments
     * @param array             $aargs  Additional arguments
     *
     * @psalm-param array|\Generator<mixed, mixed, mixed, array> $args
     *
     * @return \Amp\Promise
     */
    public function methodCallWrite(string $method, $args = [
    ], array $aargs = [
      'msg_id' => null,
    ], array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$method, $args, $aargs, $extra]);
    }
    /**
     * Escape method name.
     *
     * @param string $method Method name
     *
     * @return string
     */
    public function methodEscape(string $method): string
    {
        return \danog\MadelineProto\StrTools::methodEscape($method);
    }
    /**
     * Convert double to binary version.
     *
     * @param float $value Value to convert
     *
     * @return string
     */
    public function packDouble(float $value): string
    {
        return \danog\MadelineProto\Tools::packDouble($value);
    }
    /**
     * Convert integer to base256 signed int.
     *
     * @param integer $value Value to convert
     *
     * @return string
     */
    public function packSignedInt(int $value): string
    {
        return \danog\MadelineProto\Tools::packSignedInt($value);
    }
    /**
     * Convert integer to base256 long.
     *
     * @param int $value Value to convert
     *
     * @return string
     */
    public function packSignedLong(int $value): string
    {
        return \danog\MadelineProto\Tools::packSignedLong($value);
    }
    /**
     * Convert value to unsigned base256 int.
     *
     * @param int $value Value
     *
     * @return string
     */
    public function packUnsignedInt(int $value): string
    {
        return \danog\MadelineProto\Tools::packUnsignedInt($value);
    }
    /**
     * Check if peer is present in internal peer database.
     *
     * @param mixed $id Peer
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<bool>
     */
    public function peerIsset($id, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$id, $extra]);
    }
    /**
     * Login as user.
     *
     * @param string  $number   Phone number
     * @param integer $sms_type SMS type
     *
     * @return \Amp\Promise
     */
    public function phoneLogin($number, $sms_type = 5, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$number, $sms_type, $extra]);
    }
    /**
     * Positive modulo
     * Works just like the % (modulus) operator, only returns always a postive number.
     *
     * @param int $a A
     * @param int $b B
     *
     * @return int Modulo
     */
    public function posmod(int $a, int $b): int
    {
        return \danog\MadelineProto\Tools::posmod($a, $b);
    }
    /**
     * Get random string of specified length.
     *
     * @param integer $length Length
     *
     * @return string Random string
     */
    public function random(int $length): string
    {
        return \danog\MadelineProto\Tools::random($length);
    }
    /**
     * Get random integer.
     *
     * @param integer $modulus Modulus
     *
     * @return int
     */
    public function randomInt(int $modulus = 0): int
    {
        return \danog\MadelineProto\Tools::randomInt($modulus);
    }
    /**
     * Asynchronously read line.
     *
     * @param string $prompt Prompt
     *
     * @return \Amp\Promise<string>
     */
    public function readLine(string $prompt = '')
    {
        return \danog\MadelineProto\Tools::readLine($prompt);
    }
    /**
     * Rekey secret chat.
     *
     * @param int $chat Secret chat to rekey
     *
     * @return \Amp\Promise
     */
    public function rekey(int $chat, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$chat, $extra]);
    }
    /**
     * Report an error to the previously set peer.
     *
     * @param string $message   Error to report
     * @param string $parseMode Parse mode
     *
     * @return \Amp\Promise
     */
    public function report(string $message, string $parseMode = '', array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$message, $parseMode, $extra]);
    }
    /**
     * Request VoIP call.
     *
     * @param mixed $user User
     *
     * @return \Amp\Promise
     */
    public function requestCall($user, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$user, $extra]);
    }
    /**
     * Request secret chat.
     *
     * @param mixed $user User to start secret chat with
     *
     * @return \Amp\Promise
     */
    public function requestSecretChat($user, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$user, $extra]);
    }
    /**
     * Reset the update state and fetch all updates from the beginning.
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function resetUpdateState()
    {
        $this->__call(__FUNCTION__, []);
    }
    /**
     * Resolve username (use getInfo instead).
     *
     * @param string $username Username
     *
     * @return \Amp\Promise
     */
    public function resolveUsername(string $username, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$username, $extra]);
    }
    /**
     * Restart update loop.
     *
     * @return void
     */
    public function restart(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Rethrow error catched in strand.
     *
     * @param \Throwable $e    Exception
     * @param string     $file File where the strand started
     *
     * @psalm-suppress InvalidScope
     *
     * @return void
     */
    public function rethrow(\Throwable $e, $file = ''): void
    {
        \danog\MadelineProto\Tools::rethrow($e, $file);
    }
    /**
     * null-byte RLE decode.
     *
     * @param string $string Data to decode
     *
     * @return string
     */
    public function rleDecode(string $string): string
    {
        return \danog\MadelineProto\Tools::rleDecode($string);
    }
    /**
     * null-byte RLE encode.
     *
     * @param string $string Data to encode
     *
     * @return string
     */
    public function rleEncode(string $string): string
    {
        return \danog\MadelineProto\Tools::rleEncode($string);
    }
    /**
     * Get secret chat status.
     *
     * @param int $chat Chat ID
     *
     * @psalm-return int|\Amp\Promise<int>
     * @return mixed
     */
    public function secretChatStatus(int $chat)
    {
        return $this->__call(__FUNCTION__, [$chat]);
    }
    /**
     * Set update handling callback.
     *
     * @param callable $callback Callback
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function setCallback($callback)
    {
        $this->__call(__FUNCTION__, [$callback]);
    }
    /**
     * Set event handler.
     *
     * @param class-string<EventHandler> $eventHandler Event handler
     *
     * @return \Amp\Promise
     */
    public function setEventHandler(string $eventHandler, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$eventHandler, $extra]);
    }
    /**
     * Set NOOP update handler, ignoring all updates.
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function setNoop()
    {
        $this->__call(__FUNCTION__, []);
    }
    /**
     * Set peer(s) where to send errors occurred in the event loop.
     *
     * @param int|string $userOrId Username(s) or peer ID(s)
     *
     * @return \Amp\Promise
     */
    public function setReportPeers($userOrId, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$userOrId, $extra]);
    }
    /**
     * Sets a private variable in an object.
     *
     * @param object $obj Object
     * @param string $var Attribute name
     * @param mixed  $val Attribute value
     *
     * @psalm-suppress InvalidScope
     *
     * @return void
     *
     * @access public
     */
    public function setVar($obj, string $var, &$val): void
    {
        \danog\MadelineProto\Tools::setVar($obj, $var, $val);
    }
    /**
     * Set web template.
     *
     * @param string $template Template
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function setWebTemplate(string $template)
    {
        $this->__call(__FUNCTION__, [$template]);
    }
    /**
     * Set webhook update handler.
     *
     * @param string $hook_url Webhook URL
     * @param string $pem_path PEM path for self-signed certificate
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function setWebhook(string $hook_url, string $pem_path = '')
    {
        $this->__call(__FUNCTION__, [$hook_url, $pem_path]);
    }
    /**
     * Setup logger.
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function setupLogger()
    {
        $this->__call(__FUNCTION__, []);
    }
    /**
     * Asynchronously sleep.
     *
     * @param int|float $time Number of seconds to sleep for
     *
     * @return \Amp\Promise
     */
    public function sleep($time)
    {
        return \danog\MadelineProto\Tools::sleep($time);
    }
    /**
     * Resolves with a two-item array delineating successful and failed Promise results.
     * The returned promise will only fail if the given number of required promises fail.
     *
     * @param array<Promise|\Generator> $promises Promises
     *
     * @return \Amp\Promise
     */
    public function some(array $promises)
    {
        return \danog\MadelineProto\Tools::some($promises);
    }
    /**
     * Log in to telegram (via CLI or web).
     *
     * @return \Amp\Promise
     */
    public function start(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Stop update loop.
     *
     * @return void
     */
    public function stop(array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$extra]);
    }
    /**
     * Convert TD to MTProto parameters.
     *
     * @param array $params Parameters
     *
     * @return \Amp\Promise<array>
     */
    public function tdToMTProto(array $params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Convert TD parameters to tdcli.
     *
     * @param mixed $params Parameters
     *
     * @return mixed
     */
    public function tdToTdcli($params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Convert tdcli parameters to tdcli.
     *
     * @param array $params Params
     * @param array $key    Key
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function tdcliToTd(&$params, $key = null)
    {
        return $this->__call(__FUNCTION__, [$params, $key]);
    }
    /**
     * Create an artificial timeout for any \Generator or Promise.
     *
     * @param \Generator|Promise $promise
     * @param integer $timeout
     *
     * @return \Amp\Promise
     */
    public function timeout($promise, int $timeout)
    {
        return \danog\MadelineProto\Tools::timeout($promise, $timeout);
    }
    /**
     * Creates an artificial timeout for any `Promise`.
     *
     * If the promise is resolved before the timeout expires, the result is returned
     *
     * If the timeout expires before the promise is resolved, a default value is returned
     *
     * @template TReturnAlt
     * @template TReturn
     * @template TGenerator as \Generator<mixed, mixed, mixed, TReturn>
     *
     * @param Promise|Generator $promise Promise to which the timeout is applied.
     * @param int               $timeout Timeout in milliseconds.
     * @param mixed             $default
     *
     * @psalm-param Promise<TReturn>|TGenerator $promise Promise to which the timeout is applied.
     * @psalm-param TReturnAlt $default
     *
     * @return \Amp\Promise<TReturn>|Promise<TReturnAlt>
     *
     * @throws \TypeError If $promise is not an instance of \Amp\Promise, \Generator or \React\Promise\PromiseInterface.
     */
    public function timeoutWithDefault($promise, int $timeout, $default = null)
    {
        return \danog\MadelineProto\Tools::timeoutWithDefault($promise, $timeout, $default);
    }
    /**
     * Convert to camelCase.
     *
     * @param string $input String
     *
     * @return string
     */
    public function toCamelCase(string $input): string
    {
        return \danog\MadelineProto\StrTools::toCamelCase($input);
    }
    /**
     * Convert to snake_case.
     *
     * @param string $input String
     *
     * @return string
     */
    public function toSnakeCase(string $input): string
    {
        return \danog\MadelineProto\StrTools::toSnakeCase($input);
    }
    /**
     * Convert MTProto channel ID to bot API channel ID.
     *
     * @param int $id MTProto channel ID
     *
     * @return int
     */
    public function toSupergroup($id): int
    {
        return \danog\MadelineProto\MTProto::toSupergroup($id);
    }
    /**
     * Escape type name.
     *
     * @param string $type String to escape
     *
     * @return string
     */
    public function typeEscape(string $type): string
    {
        return \danog\MadelineProto\StrTools::typeEscape($type);
    }
    /**
     * Unpack binary double.
     *
     * @param string $value Value to unpack
     *
     * @return float
     */
    public function unpackDouble(string $value): float
    {
        return \danog\MadelineProto\Tools::unpackDouble($value);
    }
    /**
     * Unpack bot API file ID.
     *
     * @param string $fileId Bot API file ID
     *
     * @psalm-return array|\Amp\Promise<array>
     * @return mixed
     */
    public function unpackFileId(string $fileId)
    {
        return $this->__call(__FUNCTION__, [$fileId]);
    }
    /**
     * Unpack base256 signed int.
     *
     * @param string $value base256 int
     *
     * @return integer
     */
    public function unpackSignedInt(string $value): int
    {
        return \danog\MadelineProto\Tools::unpackSignedInt($value);
    }
    /**
     * Unpack base256 signed long.
     *
     * @param string $value base256 long
     *
     * @return integer
     */
    public function unpackSignedLong(string $value): int
    {
        return \danog\MadelineProto\Tools::unpackSignedLong($value);
    }
    /**
     * Unpack base256 signed long to string.
     *
     * @param string|int|array $value base256 long
     *
     * @return string
     */
    public function unpackSignedLongString($value): string
    {
        return \danog\MadelineProto\Tools::unpackSignedLongString($value);
    }
    /**
     * Unset event handler.
     *
     * @param bool $disableUpdateHandling Whether to also disable internal update handling (will cause errors, otherwise will simply use the NOOP handler)
     *
     * @psalm-return void|\Amp\Promise<void>
     * @return mixed
     */
    public function unsetEventHandler(bool $disableUpdateHandling = false)
    {
        $this->__call(__FUNCTION__, [$disableUpdateHandling]);
    }
    /**
     * Update the 2FA password.
     *
     * The params array can contain password, new_password, email and hint params.
     *
     * @param array $params The params
     *
     * @return \Amp\Promise
     */
    public function update2fa(array $params, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$params, $extra]);
    }
    /**
     * Parse, update and store settings.
     *
     * @param SettingsAbstract $settings Settings
     *
     * @return \Amp\Promise
     */
    public function updateSettings(\danog\MadelineProto\SettingsAbstract $settings, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$settings, $extra]);
    }
    /**
     * Upload file.
     *
     * @param FileCallbackInterface|string|array $file      File, URL or Telegram file to upload
     * @param string                             $fileName  File name
     * @param callable                           $cb        Callback (DEPRECATED, use FileCallbackInterface)
     * @param boolean                            $encrypted Whether to encrypt file for secret chats
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function upload($file, string $fileName = '', $cb = null, bool $encrypted = false, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$file, $fileName, $cb, $encrypted, $extra]);
    }
    /**
     * Upload file to secret chat.
     *
     * @param FileCallbackInterface|string|array $file      File, URL or Telegram file to upload
     * @param string                             $fileName  File name
     * @param callable                           $cb        Callback (DEPRECATED, use FileCallbackInterface)
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function uploadEncrypted($file, string $fileName = '', $cb = null, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$file, $fileName, $cb, $extra]);
    }
    /**
     * Upload file from callable.
     *
     * The callable must accept two parameters: int $offset, int $size
     * The callable must return a string with the contest of the file at the specified offset and size.
     *
     * @param mixed    $callable  Callable
     * @param integer  $size      File size
     * @param string   $mime      Mime type
     * @param string   $fileName  File name
     * @param callable $cb        Callback (DEPRECATED, use FileCallbackInterface)
     * @param boolean  $seekable  Whether chunks can be fetched out of order
     * @param boolean  $encrypted Whether to encrypt file for secret chats
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<array{_: string, id: string, parts: int, name: string, mime_type: string, key_fingerprint?: mixed, key?: mixed, iv?: mixed, md5_checksum: string}>
     */
    public function uploadFromCallable(callable $callable, int $size, string $mime, string $fileName = '', $cb = null, bool $seekable = true, bool $encrypted = false, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$callable, $size, $mime, $fileName, $cb, $seekable, $encrypted, $extra]);
    }
    /**
     * Upload file from stream.
     *
     * @param mixed    $stream    PHP resource or AMPHP async stream
     * @param integer  $size      File size
     * @param string   $mime      Mime type
     * @param string   $fileName  File name
     * @param callable $cb        Callback (DEPRECATED, use FileCallbackInterface)
     * @param boolean  $encrypted Whether to encrypt file for secret chats
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function uploadFromStream($stream, int $size, string $mime, string $fileName = '', $cb = null, bool $encrypted = false, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$stream, $size, $mime, $fileName, $cb, $encrypted, $extra]);
    }
    /**
     * Reupload telegram file.
     *
     * @param mixed    $media     Telegram file
     * @param callable $cb        Callback (DEPRECATED, use FileCallbackInterface)
     * @param boolean  $encrypted Whether to encrypt file for secret chats
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function uploadFromTgfile($media, $cb = null, bool $encrypted = false, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$media, $cb, $encrypted, $extra]);
    }
    /**
     * Upload file from URL.
     *
     * @param string|FileCallbackInterface $url       URL of file
     * @param integer                      $size      Size of file
     * @param string                       $fileName  File name
     * @param callable                     $cb        Callback (DEPRECATED, use FileCallbackInterface)
     * @param boolean                      $encrypted Whether to encrypt file for secret chats
     *
     * @return \Amp\Promise
     *
     * @psalm-return \Amp\Promise<mixed>
     */
    public function uploadFromUrl($url, int $size = 0, string $fileName = '', $cb = null, bool $encrypted = false, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$url, $size, $fileName, $cb, $encrypted, $extra]);
    }
    /**
     * Mark sponsored message as read.
     *
     * @param int|array $peer Channel ID, or Update, or Message, or Peer.
     * @param string|array{random_id: string} $message Random ID or sponsored message to mark as read.
     *
     * @return \Amp\Promise Bool
     */
    public function viewSponsoredMessage($peer, $message, array $extra = [])
    {
        return $this->__call(__FUNCTION__, [$peer, $message, $extra]);
    }
    /**
     * Synchronously wait for a promise|generator.
     *
     * @param \Generator|Promise $promise      The promise to wait for
     * @param boolean            $ignoreSignal Whether to ignore shutdown signals
     *
     * @return mixed
     */
    public function wait($promise, $ignoreSignal = false)
    {
        return \danog\MadelineProto\Tools::wait($promise, $ignoreSignal);
    }
}
